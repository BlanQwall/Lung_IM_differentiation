---
subtitle: "10-DE genes across pseudotime"
# bibliography: bib.bib
link-citations: yes
date: "`r format (Sys.time(), format='%Y-%m-%d %H:%M:%S %z')`"
output: 
  #html_document
  pdf_document:
    pandoc_args:
      - '../common.yaml'
      - --listings
    includes:
      in_header: '../preamble.tex'
    toc: true
    number_sections: true
    fig_width: 7
    fig_height: 6
    fig_caption: true
    df_print: tibble
---

```{r include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

\newpage

# Description





# Prepare data

```{r}
suppressMessages(
{
library(Seurat)
library(ComplexHeatmap)
library(ggplot2)
library(dplyr)
library(RColorBrewer)
library(circlize)
library(monocle3)
})

mo <- readRDS(file = "../9-Monocle_analysis_and_pseudotime_estimation/Mono_to_IM.cds")

```


# DE gene expression across IM-differentiation

[DE genes across pseudotime of IM differentiation](#de-genes)
## Across pseudotime of IM differentiation

```{r echo=FALSE, results='hide', message = FALSE}
modulated_genes <- graph_test(mo, neighbor_graph = "principal_graph", cores = 4)
genes <- row.names(subset(modulated_genes, q_value == 0 & morans_I > 0.25))
length(genes)
```

Prepare matrix with z-scores, smoothened and scaled data across pseudotime for heatmap. 

```{r}
pt.matrix <- exprs(mo)[match(genes,rownames(rowData(mo))),order(pseudotime(mo))]
cellnames <- colnames(pt.matrix)
#Can also use "normalized_counts" instead of "exprs" to use various normalization methods, for example:
#normalized_counts(cds, norm_method = "log")

pt.matrix <- t(apply(pt.matrix,1,function(x){smooth.spline(x,df=3)$y}))
pt.matrix <- t(apply(pt.matrix,1,function(x){(x-mean(x))/sd(x)}))
rownames(pt.matrix) <- genes
colnames(pt.matrix) <- cellnames
```

Show DE genes in unsupervised heatmap. 

```{r fig.width=8, fig.height=10}
#K means with 6 groups
htkm <- Heatmap(
  pt.matrix,
  # use_raster = FALSE, # use FALSE to export to vector image. 
  name                         = "z-score",
  col                          = colorRamp2(seq(from=-2,to=2,length=11),rev(brewer.pal(11, "Spectral"))),
  show_row_names               = FALSE,
  show_column_names            = FALSE,
  row_names_gp                 = gpar(fontsize = 3),
  row_km = 6, 
  row_km_repeats = 31, 
  row_dend_reorder = TRUE, 
  row_title_rot                = 0,
  cluster_rows                 = TRUE,
  cluster_row_slices           = FALSE,
  cluster_columns              = FALSE, 
)

htkm <- draw(htkm)
```
*In this heatmap, the x axis is pseudotime, which represents differentiation state from monocytes (left) to IMs (right). *

## Annotate the cells associated to either differentiation of CD206+ IMs or CD206- IMs

```{r}
library(magrittr)
# Get the closest vertice for every cell
y_to_cells <-  mo@principal_graph_aux$UMAP$pr_graph_cell_proj_closest_vertex%>%as.data.frame()

y_to_cells$cells <- rownames(y_to_cells)
y_to_cells$Y <- y_to_cells$V1


# Get the root vertices
# It is the same node as above
root <- mo@principal_graph_aux$UMAP$root_pr_nodes

principalgraph <- mo@principal_graph$UMAP

# Get the other endpoints
endpoints <- names(which(igraph::degree(principalgraph ) == 1))
endpoints <- endpoints[!endpoints %in% root]

# For each endpoint
cellWeights <- lapply(endpoints, function(endpoint) {
  # We find the path between the endpoint and the root
  path <- igraph::shortest_paths(principalgraph, root, endpoint)$vpath[[1]]
  path <- as.character(path)
  # We find the cells that map along that path
  df <- y_to_cells[y_to_cells$Y %in% path, ]
  df <- data.frame(weights = as.numeric(colnames(mo) %in% df$cells))
  colnames(df) <- endpoint
  return(df)
  }) %>% do.call(what = 'cbind', args = .) %>%
    as.matrix()
rownames(cellWeights) <- colnames(mo)
colnames(cellWeights) <- c("CD206_IM branch", "MHCII_IM branch")
pseudotime <- matrix(mo@principal_graph_aux$UMAP$pseudotime, ncol = ncol(cellWeights),
                     nrow = ncol(mo), byrow = FALSE)
rownames(pseudotime) <- colnames(mo)
```

# TradeSeq analysis for the differentiation of monocytes to either of IM subsets 

## Construct sce object for TradeSeq


```{r}
suppressMessages(library(tradeSeq))
```

```{r eval=FALSE}
# this step is VERY time consuming
sce <- fitGAM(counts = mo@assays@data$counts, 
              pseudotime = pseudotime, 
              cellWeights = cellWeights)

saveRDS(sce, file = "./sce.4339cells.newversion.Rds")
```

```{r include=FALSE}
sce <- readRDS(file = "./sce.4339cells.Rds")
```

[Between-lineage comparisons (CD206+ IM vs CD206- IM differentiation)](#wald-calc)
## Between-lineage comparisons (CD206+ IM vs CD206- IM differentiation)

Association of gene expression with pseudotime (find significant DE genes along pseudotime). 

```{r}
assoRes <- associationTest(sce)
endRes <- diffEndTest(sce)
head(assoRes)
```

Plot the most sig gene: 
```{r}
library(ggplot2)
o <- order(endRes$waldStat, decreasing = TRUE)
sigGene <- names(sce)[o[1]]
plotSmoothers(sce, counts = counts(sce), gene = sigGene
              #, curvesCol = c("#33A02C", "#B2DF8A")
              ) + ggtitle(sigGene) 
#+ scale_color_manual(
#   name = "Lineage",                                                                    labels = c("CD206_IM branch", "MHCII_IM branch"), 
#   values = c("#33A02C", "#B2DF8A"))
```

What's the top genes? 
```{r}
names(sce)[o[1:20]]
```

## Clustering using RSEC, clusterExperiment

> tradeSeq provides the functionality to cluster genes according to their expression pattern along the lineages with the clusterExpressionPatterns function. A number of equally spaced points for every lineage are selected to perform the clustering, and the number of points can be selected with the nPoints argument. (from `vignette("tradeSeq")`)

```{r}
library(clusterExperiment)
nPointsClus <- 20 # The number of points to use for clustering the expression patterns.. 
clusPat <- clusterExpressionPatterns(sce, 
                                     nPoints = nPointsClus,
                                     genes = genes,
                                     random.seed = 43, 
                                     beta = 0.2
                                     )
```

```{r}
clusterLabels <- primaryCluster(clusPat$rsec)
```


```{r fig.width=12, fig.height=12}
cUniq <- unique(clusterLabels) # 
cUniq <- cUniq[!cUniq == -1] # remove unclustered genes 

# cUniq <- cUniq[cUniq == -1]
#Any samples not found as part of a homogenous set of clusters at that point will be classified as unclustered (given a value of -1)

# beta: value between 0 and 1 to decide how stable clustership membership has to be before 'finding' and removing the cluster.
if (exists("p.total")) { rm(p.total)}

for (xx in cUniq) {
  cId <- which(clusterLabels == xx)
  p <- ggplot(data = data.frame(x = 1:nPointsClus,
                                y = rep(range(clusPat$yhatScaled[cId, ]),
                                        nPointsClus / 2)),
              aes(x = x, y = y)) +
    geom_point(alpha = 0) +
    labs(title = paste0("Cluster ", xx),  x = "Pseudotime", y = "Normalized expression") +
    theme_classic() +
    theme(plot.title = element_text(hjust = 0.5))
  for (ii in 1:length(cId)) {
    geneId <- rownames(clusPat$yhatScaled)[cId[ii]]
    p <- p +
      geom_line(data = data.frame(x = rep(1:nPointsClus, 2),
                                  y = clusPat$yhatScaled[geneId, ],
                                  lineage = rep(0:1, each = nPointsClus)),
                aes(col = as.character(lineage), group = lineage), lwd = 1.5)
  }
  p <- p + guides(color = "none") +
    scale_color_manual(values = c("#33A02C", "#B2DF8A"),
                       breaks = c("0", "1"))
  if (exists("p.total")) { p.total <- p.total + p} else {p.total <- p}
}
  print(p.total)
```

# Show gene expression pattern calculated by TradeSeq in heatmap

## Data preparation

Here we use the DE genes calculated in [DE genes across pseudotime of IM differentiation](#de-genes). 

```{r}
yhatSmooth <- predictSmooth(sce, gene = genes, nPoints = 100, tidy = FALSE)
yhatSmoothScaled <- t(scale(t(yhatSmooth)))
```


## Draw heatmap

```{r}
heatSmooth <- Heatmap(yhatSmoothScaled, cluster_columns = FALSE, show_row_names = FALSE, show_column_names = FALSE, row_km = 4)
heatSmooth <- draw(heatSmooth)
```
*Two IM differentiation show similar patterns but some genes (especially cluster 2 and 1) are different in CD206+ and CD206-.  *

## Annotate DE genes as CD206+/CD206- IM differentiation specific or common genes

According to the heatmap above, some of DE genes should remain unchanged (common) and half of them are specific to one of two IM differentiation. 

We use wald statistic calculated in diffEndTest to annotate the "common" genes and "specific" genes. (in [Between-lineage comparisons (CD206+ IM vs CD206- IM differentiation)](#wald-calc))

```{r}
endRes.DE <- endRes[rownames(yhatSmooth), ]
summary(endRes.DE$waldStat)
```

Let's use waldStat > 40 and logFC > 2 as cut threshold. 

```{r}
genes.changed <- rownames(filter(endRes.DE, waldStat > 70 & (logFC1_2 > 2 | logFC1_2 < -2) ))
genes.noChange <- setdiff(rownames(endRes.DE) , genes.changed)
```

Make heatmap with unchanged/common genes. 

```{r fig.width=8, fig.height=12}
heatSmooth_cd206.unchanged <- Heatmap(yhatSmoothScaled[genes.noChange, 100:1], cluster_columns = FALSE,  show_row_names = FALSE, show_column_names = FALSE, column_title = "CD206+ IM")

heatSmooth_mhcii.unchanged <- Heatmap(yhatSmoothScaled[genes.noChange, 101:200], cluster_columns = FALSE,  show_row_names = TRUE, row_names_gp = gpar(fontsize = 3), show_column_names = FALSE, column_title = "MHCII+ IM")

heatSmooth_combined.unchanged <- draw ( heatSmooth_cd206.unchanged + heatSmooth_mhcii.unchanged, column_title = "Common genes", auto_adjust = FALSE)
```

## Daw heatmap with expression patterns of unchanged/common genes in the order of pseudotime

Let's find the expression peak of each gene: 

```{r}
orderbyExpressionPeak <- function(x, # matrix
                                  decreasing = FALSE, 
                                  output.position = FALSE # if true, give relative position 0 - 1, or output order. 
                                  ) {
  indx.peak <- apply(x, 1 , which.max)
  
  if(output.position) {
    po <- indx.peak/nrow(x)
    if (! length(rownames(x)) == 0) {names(po) <- rownames(x)}
    return(po)
  } else {
    o <- order(indx.peak) 
    if (! length(rownames(x)) == 0) {names(o) <- rownames(x)[o]}
    return (o)}
}
```

Make average peak pseudotime peak for each gene: 

```{r fig.height=10, fig.width=8}
po.cd206 <- orderbyExpressionPeak(yhatSmoothScaled[genes.noChange, 1:100], output.position = TRUE)
po.mhcii <- orderbyExpressionPeak(yhatSmoothScaled[genes.noChange, 101:200], output.position = TRUE)
order.mean <- order ( ( po.cd206 + po.mhcii ) /2)

heatSmooth_cd206.unchanged.ordered <- Heatmap(yhatSmoothScaled[genes.noChange, 100:1], cluster_columns = FALSE,  show_row_names = FALSE, show_column_names = FALSE, row_order = order.mean,  column_title = "CD206+ IM")

heatSmooth_combined.unchanged.ordered <- draw ( heatSmooth_cd206.unchanged.ordered + heatSmooth_mhcii.unchanged, column_title = "Common genes", auto_adjust = FALSE)
```

```{r}
pdf(file = "../Figures/Heatmap_common_genes_IMs_diff_across_pseudotime.pdf", width = 8, height = 10)
heatSmooth_combined.unchanged.ordered
dev.off()
```


## Make with changed/specific genes

```{r fig.height=10, fig.width=8}
heatSmooth_cd206.changed <- Heatmap(yhatSmoothScaled[genes.changed, 100:1], cluster_columns = FALSE,  show_row_names = FALSE, cluster_rows = hclust(dist(yhatSmoothScaled[genes.changed, ])), show_column_names = FALSE, column_title = "CD206+ IM")

heatSmooth_mhcii.changed <- Heatmap(yhatSmoothScaled[genes.changed, 101:200], cluster_columns = FALSE,  show_row_names = TRUE,row_names_gp = gpar(fontsize = 8), show_column_names = FALSE, column_title = "MHCII+ IM")

heatSmooth_combined.changed <- draw ( heatSmooth_cd206.changed + heatSmooth_mhcii.changed, column_title = "Specific genes", split = 2)
```

# Functionality analysis of DE genes across pseudotime (common genes)

```{r}
common.genes <- heatSmooth_cd206.unchanged.ordered@row_names_param$labels[heatSmooth_cd206.unchanged.ordered@row_order]
```





# Session information 

R sesssion: 

```{r}
sessionInfo()
```


# References



